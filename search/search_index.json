{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"pySPAC Documentation","text":"<p>pySPAC (python Solar Phase curve Analysis and Characterization) is a library for analyzing and fitting astronomical phase curves of asteroids and other small solar system bodies.</p>"},{"location":"#repository-links","title":"Repository &amp; Links","text":"<ul> <li>GitHub Repository: https://github.com/rcboufleur/pySPAC</li> <li>PyPI Package: https://pypi.org/project/pyspac/</li> <li>Documentation: https://rcboufleur.github.io/pySPAC/</li> <li>Issue Tracker: https://github.com/rcboufleur/pySPAC/issues</li> </ul>"},{"location":"#what-pyspac-does","title":"What pySPAC Does","text":"<p>pySPAC determines the absolute magnitude (H) and other phase function parameters from phase angle (\u03b1) and reduced magnitude observations using:</p> <ul> <li>Standard IAU photometric models: (H, G), (H, G\u2081, G\u2082), (H, G\u2081\u2082), and linear fit</li> <li>Weighted least-squares fitting with observational uncertainties</li> <li>Monte Carlo uncertainty analysis</li> <li>Model generation from fitted parameters</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>import numpy as np\nfrom pyspac import PhaseCurve\n\n# Observational data\nangles = np.array([0.17, 0.63, 0.98, 1.62, 4.95, 9.78,\n                  12.94, 13.27, 13.81, 17.16, 18.52, 19.4])\nmags = np.array([6.911, 7.014, 7.052, 7.105, 7.235, 7.341,\n                      7.425, 7.427, 7.437, 7.511, 7.551, 7.599])\nerrors = np.array([0.02, 0.02, 0.03, 0.03, 0.04, 0.04,\n                   0.02, 0.02, 0.03, 0.03, 0.04, 0.04])\n\n# Create object and fit model\npc = PhaseCurve(angle=angles, magnitude=mags, magnitude_unc=errors)\npc.fitModel(model=\"HG\", method=\"trust-constr\")\npc.summary()\n\n# Monte Carlo uncertainties\npc.monteCarloUncertainty(n_simulations=500, model=\"HG\", method=\"trust-constr\")\npc.summary()\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install pyspac\n</code></pre>"},{"location":"#how-to-cite","title":"How to Cite","text":"<p>If you use pySPAC in your research, please cite:</p> <p></p> <pre><code>@software{boufleur_pyspac_2025,\n  author = {Boufleur, Rodrigo Carlos},\n  title = {pySPAC: Solar Phase curve Analysis and Characterization},\n  url = {https://github.com/rcboufleur/pySPAC},\n  doi = {10.5281/zenodo.17163112},\n  version = {0.1.0},\n  year = {2025}\n}\n</code></pre> <p>Additionally, please cite the relevant papers for the models you employ:</p> <ul> <li>HG System: Bowell, E., et al. (1989). \"Application of photometric models to asteroids.\" In Asteroids II (pp. 524-556).</li> <li>HG1G2 &amp; HG12 Systems: Muinonen, K., et al. (2010). \"A three-parameter magnitude phase function for asteroids.\" Icarus, 209(2), 542-555.</li> <li>HG12PEN System: Penttil\u00e4, A., et al. (2016). \"Asteroid H, G1, G2 and H, G12 phase function performance with sparse data.\" Planetary and Space Science, 123, 117-122.</li> </ul>"},{"location":"#navigation","title":"Navigation","text":"<ul> <li>Getting Started - Basic workflow</li> <li>Setting Up Objects - Creating PhaseCurve objects</li> <li>Fitting Models - Model fitting procedures</li> <li>Setting Boundaries - Parameter constraints</li> <li>Models and Methods - Available models and fitting methods</li> <li>Monte Carlo Uncertainties - Error estimation</li> <li>Save and Load - Data persistence</li> <li>Plotting Results - Visualization</li> <li>Generate Models - Synthetic phase curves</li> </ul>"},{"location":"boundaries/","title":"Setting Boundaries","text":""},{"location":"boundaries/#initial_conditions-parameter","title":"initial_conditions Parameter","text":"<p>The <code>initial_conditions</code> parameter in <code>fitModel()</code> controls parameter bounds and initial guesses.</p> <pre><code>initial_conditions = [\n    [initial_guess, min_boundary, max_boundary, vary_flag],\n    [initial_guess, min_boundary, max_boundary, vary_flag],\n    # ... one list per parameter\n]\n</code></pre>"},{"location":"boundaries/#parameter-format","title":"Parameter Format","text":"<p>Each parameter list contains: - initial_guess (float): Starting value for optimization - min_boundary (float or None): Lower bound (None = no limit) - max_boundary (float or None): Upper bound (None = no limit) - vary_flag (bool): True to optimize, False to fix at initial_guess</p>"},{"location":"boundaries/#parameter-order-by-model","title":"Parameter Order by Model","text":"Model Parameter Order HG [H_settings, G_settings] HG12 [H_settings, G12_settings] HG12PEN [H_settings, G12_settings] HG1G2 [H_settings, G1_settings, G2_settings] LINEAR [H_settings, beta_settings]"},{"location":"boundaries/#basic-examples","title":"Basic Examples","text":""},{"location":"boundaries/#setting-initial-guesses","title":"Setting Initial Guesses","text":"<pre><code># HG model with custom starting values\ninitial_conditions = [\n    [5.5, None, None, True],  # H: start at 5.5, no bounds, vary\n    [0.20, None, None, True]   # G: start at 0.20, no bounds, vary\n]\n\npc.fitModel(model=\"HG\", method=\"trust-constr\", initial_conditions=initial_conditions)\n</code></pre>"},{"location":"boundaries/#setting-boundaries_1","title":"Setting Boundaries","text":"<pre><code># HG model with physical bounds\ninitial_conditions = [\n    [5.0, 5.0, 20.0, True],  # H: range 5-20 magnitudes\n    [0.15, 0.0, 1.0, True]     # G: range 0-1 (physical constraint)\n]\n\npc.fitModel(model=\"HG\", method=\"trust-constr\", initial_conditions=initial_conditions)\n</code></pre>"},{"location":"boundaries/#fixing-parameters","title":"Fixing Parameters","text":"<pre><code># Fix G at standard value, only fit H\ninitial_conditions = [\n    [5.0, 5.0, 20.0, True],   # H: vary between 5-20\n    [0.15, None, None, False]   # G: fixed at 0.15\n]\n\npc.fitModel(model=\"HG\", method=\"trust-constr\", initial_conditions=initial_conditions)\n</code></pre>"},{"location":"boundaries/#model-specific-examples","title":"Model-Specific Examples","text":""},{"location":"boundaries/#hg-model","title":"HG Model","text":"<pre><code>hg_conditions = [\n    [15.0, 5.0, 25.0, True],    # H: 5-25 mag range\n    [0.15, 0.0, 1.0, True]      # G: 0-1 physical range\n]\n\npc.fitModel(model=\"HG\", method=\"trust-constr\", initial_conditions=hg_conditions)\n</code></pre>"},{"location":"boundaries/#hg1g2-model","title":"HG1G2 Model","text":"<pre><code>hg1g2_conditions = [\n    [15.0, 5.0, 25.0, True],    # H: absolute magnitude\n    [0.30, 0.0, 1.0, True],     # G1: first slope parameter\n    [0.15, 0.0, 1.0, True]      # G2: second slope parameter\n]\n\npc.fitModel(model=\"HG1G2\", method=\"trust-constr\", initial_conditions=hg1g2_conditions)\n</code></pre>"},{"location":"boundaries/#hg12hg12pen-models","title":"HG12/HG12PEN Models","text":"<pre><code>hg12_conditions = [\n    [15.0, 5.0, 25.0, True],    # H: absolute magnitude\n    [0.30, -0.1, 1.0, True]     # G12: can be slightly negative\n]\n\npc.fitModel(model=\"HG12\", method=\"trust-constr\", initial_conditions=hg12_conditions)\npc.fitModel(model=\"HG12PEN\", method=\"trust-constr\", initial_conditions=hg12_conditions)\n</code></pre>"},{"location":"boundaries/#linear-model","title":"LINEAR Model","text":"<pre><code>linear_conditions = [\n    [15.0, 5.0, 25.0, True],    # H: absolute magnitude\n    [0.04, 0.0, 0.1, True]      # beta: 0.01-0.08 mag/deg typical\n]\n\npc.fitModel(model=\"LINEAR\", method=\"leastsq\", initial_conditions=linear_conditions)\n</code></pre>"},{"location":"boundaries/#multiple-starting-points","title":"Multiple Starting Points","text":"<p><pre><code># Try multiple starting points to avoid local minima\nstarting_points = [\n    [[15.0, 5.0, 20.0, True], [0.15, 0.0, 1.0, True]],\n    [[16.0, 5.0, 20.0, True], [0.25, 0.0, 1.0, True]],\n    [[14.0, 5.0, 20.0, True], [0.10, 0.0, 1.0, True]]\n]\n\nbest_rms = float('inf')\nbest_params = None\n\nfor conditions in starting_points:\n    try:\n        pc.fitModel(model=\"HG\", method=\"trust-constr\", initial_conditions=conditions)\n        rms = np.sqrt(np.mean(np.array(pc.fit_residual)**2))\n\n        if rms &lt; best_rms:\n            best_rms = rms\n            best_params = pc.params.copy()\n    except:\n        continue\n\nprint(f\"Best RMS: {best_rms:.4f}\")\nprint(f\"Best parameters: {best_params}\")\n</code></pre> <pre><code>Best RMS: 0.8549\nBest parameters: {'H': 6.93653593554117, 'G': 0.4730865728694542, 'constraint': 0.5269134271305458}\n</code></pre></p>"},{"location":"boundaries/#data-driven-initial-conditions","title":"Data-Driven Initial Conditions","text":"<pre><code># Estimate H from data\nh_estimate = np.mean(mags)  # Rough estimate\n\n# Estimate slope from data\nif len(angles) &gt;= 2:\n    slope = (mags[-1] - mags[0]) / (angles[-1] - angles[0])\n    g_estimate = np.clip(slope / 0.04, 0.0, 1.0)  # Convert to G\nelse:\n    g_estimate = 0.15\n\n# Use estimates as starting points\ndata_driven_conditions = [\n    [h_estimate, h_estimate - 2, h_estimate + 2, True],\n    [g_estimate, 0.0, 1.0, True]\n]\n\npc.fitModel(model=\"HG\", method=\"trust-constr\", initial_conditions=data_driven_conditions)\n</code></pre>"},{"location":"boundaries/#next-steps","title":"Next Steps","text":"<ul> <li>Models and Methods - Model/method compatibility details</li> <li>Monte Carlo Uncertainties - Parameter error estimation</li> <li>Save and Load - Save and load analysis results</li> </ul>"},{"location":"fitting-models/","title":"Fitting Models","text":""},{"location":"fitting-models/#fitmodel-method","title":"fitModel Method","text":"<pre><code>fitModel(model, method, initial_conditions=None)\n</code></pre> <p>Fits a photometric model to observational data using weighted least-squares.</p>"},{"location":"fitting-models/#basic-fitting","title":"Basic Fitting","text":"<p><pre><code># Create object with data\npc = PhaseCurve(angle=angles, magnitude=mags, magnitude_unc=errors)\n\n# Fit HG model\npc.fitModel(model=\"HG\", method=\"trust-constr\")\n\n# View results\npc.summary()\n</code></pre> <pre><code>================== PhaseCurve Summary ==================\nData Points:         12\nAngle Range:         0.17\u00b0 to 19.40\u00b0\nMagnitude Range:     6.91 to 7.60\n------------------------------------------------------\nFitting Status:      SUCCESS\nModel:               HG\nMethod:              trust-constr\nFit RMS:             0.9365\n------------------- Model Parameters -------------------\n  H                    6.9365\n  G                    0.4731\n======================================================\n</code></pre></p>"},{"location":"fitting-models/#available-models","title":"Available Models","text":""},{"location":"fitting-models/#hg-model","title":"HG Model","text":"<pre><code>pc.fitModel(model=\"HG\", method=\"trust-constr\")\nprint(f\"H = {pc.params['H']:.3f}\")\nprint(f\"G = {pc.params['G']:.3f}\")\n</code></pre> <ul> <li>Parameters: H (absolute magnitude), G (slope parameter)</li> <li>Reference: Bowell et al. (1989)</li> </ul>"},{"location":"fitting-models/#hg1g2-model","title":"HG1G2 Model","text":"<pre><code>pc.fitModel(model=\"HG1G2\", method=\"trust-constr\")\nprint(f\"H = {pc.params['H']:.3f}\")\nprint(f\"G1 = {pc.params['G1']:.3f}\")\nprint(f\"G2 = {pc.params['G2']:.3f}\")\n</code></pre> <ul> <li>Parameters: H, G1 (first slope), G2 (second slope). Physically-based three-parameter system.</li> <li>Reference: Muinonen et al. (2010)</li> </ul>"},{"location":"fitting-models/#hg12-model","title":"HG12 Model","text":"<pre><code>pc.fitModel(model=\"HG12\", method=\"trust-constr\")\nprint(f\"H = {pc.params['H']:.3f}\")\nprint(f\"G12 = {pc.params['G12']:.3f}\")\nprint(f\"G1 = {pc.params['G1']:.3f} (derived)\")\nprint(f\"G2 = {pc.params['G2']:.3f} (derived)\")\n</code></pre> <ul> <li>Parameters: H, G12 (combined slope parameter). Simplified two-parameter version of HG1G2.</li> <li>Derived: G1 and G2 calculated from G12</li> <li>Reference: Muinonen et al. (2010)</li> </ul>"},{"location":"fitting-models/#hg12pen-model","title":"HG12PEN Model","text":"<pre><code>pc.fitModel(model=\"HG12PEN\", method=\"trust-constr\")\n</code></pre> <ul> <li>Parameters: Same as HG12 but improved calibration. Recalibrated HG12 for better sparse data performance.</li> <li>Reference: Penttil\u00e4 et al. (2016)</li> </ul>"},{"location":"fitting-models/#linear-model","title":"LINEAR Model","text":"<pre><code>pc.fitModel(model=\"LINEAR\", method=\"leastsq\")\nprint(f\"H = {pc.params['H']:.3f}\")\nprint(f\"beta = {pc.params['beta']:.4f} mag/deg\")\n</code></pre> <ul> <li>Parameters: H, \u03b2 (linear phase coefficient in mag/deg). First-order approximation for small phase angles.</li> </ul>"},{"location":"fitting-models/#fit-results","title":"Fit Results","text":"<pre><code># After fitting, the object is updated\nprint(f\"Fitting status: {pc.fitting_status}\")      # True\nprint(f\"Model: {pc.fitting_model}\")                # \"HG\"\nprint(f\"Method: {pc.fitting_method}\")              # \"trust-constr\"\nprint(f\"Residuals: {len(pc.fit_residual)} points\") # List of residuals\n</code></pre>"},{"location":"fitting-models/#error-handling","title":"Error Handling","text":"<pre><code>try:\n    pc.fitModel(model=\"HG\", method=\"trust-constr\")\nexcept RuntimeError as e:\n    print(f\"Fitting failed: {e}\")\nexcept ValueError as e:\n    print(f\"Invalid parameters: {e}\")\n</code></pre>"},{"location":"fitting-models/#multiple-fits","title":"Multiple Fits","text":"<pre><code># Try different models\nmodels = [\"HG\", \"HG12\", \"LINEAR\"]\nresults = {}\n\nfor model in models:\n    try:\n        method = \"trust-constr\" if model != \"LINEAR\" else \"leastsq\"\n        pc.fitModel(model=model, method=method)\n        rms = np.sqrt(np.mean(np.array(pc.fit_residual)**2))\n        results[model] = {'rms': rms, 'params': pc.params.copy()}\n    except Exception as e:\n        results[model] = {'error': str(e)}\n\n# Find best fit\nbest_model = min([k for k in results if 'rms' in results[k]],\n                key=lambda x: results[x]['rms'])\nprint(f\"Best model: {best_model}\")\n</code></pre>"},{"location":"fitting-models/#weighted-vs-unweighted-fitting","title":"Weighted vs Unweighted Fitting","text":"<pre><code># Weighted fitting (when magnitude_unc provided)\npc = PhaseCurve(angle=angles, magnitude=mags, magnitude_unc=errors)\npc.fitModel(model=\"HG\", method=\"trust-constr\")  # Uses weights\n\n# Unweighted fitting\npc = PhaseCurve(angle=angles, magnitude=mags)  # No magnitude_unc\npc.fitModel(model=\"HG\", method=\"trust-constr\")  # Equal weights\n</code></pre>"},{"location":"fitting-models/#next-steps","title":"Next Steps","text":"<ul> <li>Setting Boundaries - Control parameter bounds and initial guesses</li> <li>Models and Methods - Model/method compatibility details</li> <li>Monte Carlo Uncertainties - Parameter error estimation</li> </ul>"},{"location":"generate-models/","title":"Generate Models","text":""},{"location":"generate-models/#overview","title":"Overview","text":"<p>The <code>generateModel()</code> method creates magnitude values from model parameters, enabling:</p> <ul> <li>Smooth curves for plotting fitted models</li> <li>Synthetic datasets for testing</li> <li>Theoretical phase curves from literature values</li> <li>Model extrapolation beyond data range</li> </ul>"},{"location":"generate-models/#method-signature","title":"Method Signature","text":"<pre><code>generateModel(model, degrees=None)\n</code></pre> <p>Parameters: - model (str): Model name (\"HG\", \"HG1G2\", \"HG12\", \"HG12PEN\", \"LINEAR\") - degrees (array-like, optional): Phase angles. If None, uses object's angle array</p> <p>Returns: - Magnitude values (float or numpy array)</p>"},{"location":"generate-models/#basic-usage","title":"Basic Usage","text":""},{"location":"generate-models/#from-fitted-parameters","title":"From Fitted Parameters","text":"<p><pre><code># After fitting a model\npc.fitModel(model=\"HG\", method=\"trust-constr\")\n\n# Generate at original angles\nmodel_mags = pc.generateModel(model=\"HG\")\nprint(\"Model at original angles:\", model_mags)\n\n# Generate at new angles\nnew_angles = np.array([1, 5, 10, 15, 20, 25, 30])\nextended_mags = pc.generateModel(model=\"HG\", degrees=new_angles)\nprint(\"Model at extended angles:\", extended_mags)\n</code></pre> <pre><code>Model at original angles: [6.95322579 6.99455516 7.02274888 7.06830039 7.22616926 7.35526372\n 7.42522086 7.43249424 7.44442226 7.51929385 7.54999792 7.56988952]\nModel at extended angles: [7.02428427 7.22788627 7.36022689 7.47084845 7.58344709 7.6956334\n 7.80641673]\n</code></pre></p>"},{"location":"generate-models/#single-point-generation","title":"Single Point Generation","text":"<p><pre><code># Generate magnitude at specific angle\nmag_at_10deg = pc.generateModel(model=\"HG\", degrees=10.0)\nprint(f\"Magnitude at 10\u00b0: {mag_at_10deg:.3f}\")\n\n# Generate at zero phase (absolute magnitude H)\nh_magnitude = pc.generateModel(model=\"HG\", degrees=0.0)\nprint(f\"H parameter: {pc.params['H']:.3f}\")\nprint(f\"Magnitude at 0\u00b0: {h_magnitude:.3f}\")  # Should match H\n</code></pre> <pre><code>Magnitude at 10\u00b0: 7.360\nH parameter: 6.937\nMagnitude at 0\u00b0: 6.937\n</code></pre></p>"},{"location":"generate-models/#theoretical-models","title":"Theoretical Models","text":""},{"location":"generate-models/#from-literature-parameters","title":"From Literature Parameters","text":"<p><pre><code>def create_theoretical_model(model, phase_range, **params):\n    \"\"\"Create theoretical phase curve from literature parameters.\"\"\"\n\n    angles = np.linspace(phase_range[0], phase_range[1], 100)\n    pc = PhaseCurve(angle=angles, **params)\n    magnitudes = pc.generateModel(model=model)\n\n    return angles, magnitudes\n\n# Example: Create HG model from known parameters\nangles, mags = create_theoretical_model(\n    model=\"HG\",\n    phase_range=(0, 30),\n    H=15.24,\n    G=0.15\n)\n\nprint(f\"Generated {len(angles)} points from 0\u00b0 to 30\u00b0\")\n</code></pre> <pre><code>Generated 100 points from 0\u00b0 to 30\u00b0\n</code></pre></p>"},{"location":"generate-models/#standard-asteroid-types","title":"Standard Asteroid Types","text":"<p><pre><code>def generate_standard_types():\n    \"\"\"Generate phase curves for standard asteroid taxonomic types.\"\"\"\n\n    # Typical slope parameters (G) per type\n    standard_types = {\n        'C-type': {'G': 0.15},  # Carbonaceous (dark, shallow slope)\n        'S-type': {'G': 0.25},  # Silicaceous\n        'M-type': {'G': 0.20},  # Metallic\n        'V-type': {'G': 0.30}   # Basaltic (steeper slope)\n    }\n\n    # Use a single reference H (absolute magnitude)\n    H_ref = 12.0\n\n    phase_angles = np.linspace(0, 30, 150)\n    models = {}\n\n    for ast_type, params in standard_types.items():\n        pc = PhaseCurve(angle=phase_angles, H=H_ref, **params)\n        magnitudes = pc.generateModel(model=\"HG\")\n        models[ast_type] = {\n            'angles': phase_angles,\n            'magnitudes': magnitudes,\n            'params': {'H': H_ref, **params}\n        }\n\n    return models\n\n# Generate and plot\nimport matplotlib.pyplot as plt\n\nmodels = generate_standard_types()\n\nplt.figure(figsize=(8, 4))\nfor ast_type, data in models.items():\n    plt.plot(data['angles'], data['magnitudes'],\n             label=f\"{ast_type} (G={data['params']['G']})\")\n\nplt.gca().invert_yaxis()\nplt.xlabel('Phase Angle (degrees)')\nplt.ylabel('Reduced Magnitude')\nplt.title('Standard Asteroid Type Phase Curves (HG model)')\nplt.legend()\nplt.show()\n</code></pre> </p>"},{"location":"generate-models/#model-comparisons","title":"Model Comparisons","text":""},{"location":"generate-models/#compare-different-models","title":"Compare Different Models","text":"<pre><code>def compare_photometric_models(h_value=15.0):\n    \"\"\"Compare different models with same H value.\"\"\"\n\n    model_params = {\n        'HG': {'H': h_value, 'G': 0.15},\n        'HG12': {'H': h_value, 'G12': 0.30},\n        'HG12PEN': {'H': h_value, 'G12': 0.30},\n        'HG1G2': {'H': h_value, 'G1': 0.30, 'G2': 0.15},\n        'LINEAR': {'H': h_value, 'beta': 0.04}\n    }\n\n    phase_angles = np.linspace(0, 30, 200)\n\n    plt.figure(figsize=(8, 4))\n\n    for model, params in model_params.items():\n        pc = PhaseCurve(angle=phase_angles, **params)\n        magnitudes = pc.generateModel(model=model)\n        plt.plot(phase_angles, magnitudes, linewidth=2, label=model)\n\n    plt.gca().invert_yaxis()\n    plt.xlabel('Phase Angle (degrees)')\n    plt.ylabel('Reduced Magnitude')\n    plt.title(f'Photometric Model Comparison (H = {h_value})')\n    plt.legend()\n    plt.grid(True, alpha=0.3)\n    plt.show()\n\n# Usage\ncompare_photometric_models(h_value=15.0)\n</code></pre>"},{"location":"generate-models/#parameter-sensitivity","title":"Parameter Sensitivity","text":"<pre><code>def parameter_sensitivity(model=\"HG\", base_params=None, vary_param='G'):\n    \"\"\"Analyze sensitivity to parameter variations.\"\"\"\n\n    if base_params is None:\n        base_params = {'H': 15.0, 'G': 0.15}\n\n    # Define parameter variations\n    if vary_param == 'G':\n        variations = [0.05, 0.10, 0.15, 0.20, 0.30, 0.40]\n    elif vary_param == 'H':\n        variations = [14.5, 14.7, 15.0, 15.3, 15.5, 15.8]\n    else:\n        variations = np.linspace(0.1, 0.4, 6)\n\n    phase_angles = np.linspace(0, 30, 200)\n\n    plt.figure(figsize=(8, 4))\n\n    for i, var_value in enumerate(variations):\n        # Create parameter set\n        params = base_params.copy()\n        params[vary_param] = var_value\n\n        # Generate model\n        pc = PhaseCurve(angle=phase_angles, **params)\n        magnitudes = pc.generateModel(model=model)\n\n        # Plot with color gradient\n        color = plt.cm.viridis(i / (len(variations) - 1))\n        plt.plot(phase_angles, magnitudes, color=color, linewidth=2,\n                label=f'{vary_param} = {var_value:.2f}')\n\n    plt.gca().invert_yaxis()\n    plt.xlabel('Phase Angle (degrees)')\n    plt.ylabel('Reduced Magnitude')\n    plt.title(f'{model} Model: {vary_param} Parameter Sensitivity')\n    plt.legend()\n    plt.grid(True, alpha=0.3)\n    plt.show()\n\n# Usage examples\nparameter_sensitivity(model=\"HG\", vary_param='G')\nparameter_sensitivity(model=\"HG\", vary_param='H')\n</code></pre>"},{"location":"generate-models/#synthetic-datasets","title":"Synthetic Datasets","text":""},{"location":"generate-models/#generate-test-data","title":"Generate Test Data","text":"<p><pre><code>def generate_synthetic_dataset(model, params, phase_angles, noise_level=0.02, seed=None):\n    \"\"\"Generate synthetic observational dataset with noise.\"\"\"\n\n    if seed is not None:\n        np.random.seed(seed)\n\n    # Generate perfect model\n    pc = PhaseCurve(angle=phase_angles, **params)\n    true_magnitudes = pc.generateModel(model=model)\n\n    # Add observational noise\n    noise = np.random.normal(0, noise_level, len(phase_angles))\n    observed_magnitudes = true_magnitudes + noise\n\n    # Create realistic uncertainties\n    uncertainties = np.full_like(phase_angles, noise_level)\n    uncertainties *= np.random.uniform(0.8, 1.2, len(phase_angles))\n\n    return {\n        'angles': phase_angles,\n        'magnitudes': observed_magnitudes,\n        'uncertainties': uncertainties,\n        'true_magnitudes': true_magnitudes,\n        'true_params': params\n    }\n\n# Generate test dataset\ntrue_params = {'H': 15.234, 'G': 0.187}\ntest_angles = np.array([3., 7., 11., 16., 21., 26.])\n\nsynthetic_data = generate_synthetic_dataset(\n    model=\"HG\",\n    params=true_params,\n    phase_angles=test_angles,\n    noise_level=0.03,\n    seed=42\n)\n\nprint(\"Synthetic dataset generated:\")\nprint(f\"True H: {true_params['H']:.3f}\")\nprint(f\"True G: {true_params['G']:.3f}\")\nprint(f\"Noise level: {0.03:.3f} mag\")\n</code></pre> <pre><code>Synthetic dataset generated:\nTrue H: 15.234\nTrue G: 0.187\nNoise level: 0.030 mag\n</code></pre></p>"},{"location":"generate-models/#parameter-recovery-testing","title":"Parameter Recovery Testing","text":"<p><pre><code>def test_parameter_recovery(model, true_params, n_datasets=50):\n    \"\"\"Test parameter recovery accuracy with synthetic data.\"\"\"\n\n    test_angles = np.array([5, 10, 15, 20, 25])\n    recovered_params = []\n\n    for i in range(n_datasets):\n        # Generate synthetic dataset\n        synthetic = generate_synthetic_dataset(\n            model=model,\n            params=true_params,\n            phase_angles=test_angles,\n            noise_level=0.02,\n            seed=i\n        )\n\n        # Attempt to fit\n        try:\n            pc = PhaseCurve(\n                angle=synthetic['angles'],\n                magnitude=synthetic['magnitudes'],\n                magnitude_unc=synthetic['uncertainties']\n            )\n            pc.fitModel(model=model, method=\"trust-constr\")\n            recovered_params.append(pc.params.copy())\n        except:\n            continue\n\n    # Analyze results\n    if not recovered_params:\n        print(\"No successful fits!\")\n        return\n\n    print(f\"Parameter Recovery Test ({model} model):\")\n    print(f\"Successful fits: {len(recovered_params)}/{n_datasets}\")\n    print()\n\n    for param in true_params:\n        recovered_values = [rp[param] for rp in recovered_params]\n        true_value = true_params[param]\n\n        mean_recovered = np.mean(recovered_values)\n        std_recovered = np.std(recovered_values)\n        bias = mean_recovered - true_value\n\n        print(f\"{param}:\")\n        print(f\"  True value: {true_value:.4f}\")\n        print(f\"  Mean recovered: {mean_recovered:.4f}\")\n        print(f\"  Standard deviation: {std_recovered:.4f}\")\n        print(f\"  Bias: {bias:.4f}\")\n        print()\n\n# Test recovery\ntrue_params = {'H': 15.234, 'G': 0.187}\ntest_parameter_recovery(\"HG\", true_params)\n</code></pre> <pre><code>Parameter Recovery Test (HG model):\nSuccessful fits: 50/50\n\nH:\n  True value: 15.2340\n  Mean recovered: 15.2441\n  Standard deviation: 0.0233\n  Bias: 0.0101\n\nG:\n  True value: 0.1870\n  Mean recovered: 0.1982\n  Standard deviation: 0.0248\n  Bias: 0.0112\n</code></pre></p>"},{"location":"generate-models/#model-extrapolation","title":"Model Extrapolation","text":""},{"location":"generate-models/#extend-beyond-data-range","title":"Extend Beyond Data Range","text":"<pre><code>def extrapolate_model(pc, extended_range=(0, 60)):\n    \"\"\"Extrapolate fitted model to extended phase angles.\"\"\"\n\n    if not pc.fitting_status:\n        print(\"Fit a model first\")\n        return\n\n    original_range = (np.min(pc.angle), np.max(pc.angle))\n    extended_angles = np.linspace(extended_range[0], extended_range[1], 300)\n    extended_mags = pc.generateModel(model=pc.fitting_model, degrees=extended_angles)\n\n    plt.figure(figsize=(8, 4))\n\n    # Plot original data\n    plt.errorbar(pc.angle, pc.magnitude, yerr=pc.magnitude_unc,\n                fmt='o', capsize=5, markersize=8, color='blue',\n                label='Original Data', zorder=10)\n\n    # Plot fitted model in original range\n    original_angles = np.linspace(original_range[0], original_range[1], 100)\n    original_model = pc.generateModel(model=pc.fitting_model, degrees=original_angles)\n    plt.plot(original_angles, original_model, 'b-', linewidth=3,\n            label='Fitted Model (data range)')\n\n    # Plot extrapolated model\n    plt.plot(extended_angles, extended_mags, 'r--', linewidth=2,\n            label='Extrapolated Model', alpha=0.8)\n\n    # Highlight extrapolation regions\n    if extended_range[0] &lt; original_range[0]:\n        plt.axvspan(extended_range[0], original_range[0], alpha=0.2, color='red')\n    if extended_range[1] &gt; original_range[1]:\n        plt.axvspan(original_range[1], extended_range[1], alpha=0.2, color='red')\n\n    plt.gca().invert_yaxis()\n    plt.xlabel('Phase Angle (degrees)')\n    plt.ylabel('Reduced Magnitude')\n    plt.title('Model Extrapolation')\n    plt.legend()\n    plt.grid(True, alpha=0.3)\n    plt.show()\n\n    return extended_angles, extended_mags\n\n# Usage after fitting\nextended_angles, extended_mags = extrapolate_model(pc, extended_range=(0, 45))\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>pip install pyspac\n</code></pre>"},{"location":"getting-started/#basic-workflow","title":"Basic Workflow","text":"<ol> <li>Create PhaseCurve object with observational data</li> <li>Fit a photometric model</li> <li>Estimate uncertainties with Monte Carlo</li> <li>Save results</li> </ol>"},{"location":"getting-started/#complete-example","title":"Complete Example","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom pyspac import PhaseCurve\n\n# Step 1: Define observational data\nphase_angles = np.array([0.17, 0.63, 0.98, 1.62, 4.95, 9.78,\n                        12.94, 13.27, 13.81, 17.16, 18.52, 19.4])\nmagnitudes = np.array([6.911, 7.014, 7.052, 7.105, 7.235, 7.341,\n                      7.425, 7.427, 7.437, 7.511, 7.551, 7.599])\nmag_unc = np.array([0.02, 0.02, 0.03, 0.03, 0.04, 0.04,\n                   0.02, 0.02, 0.03, 0.03, 0.04, 0.04])\n\n# Step 2: Create PhaseCurve object\npc = PhaseCurve(angle=phase_angles, magnitude=magnitudes, magnitude_unc=mag_unc)\n\n# Step 3: Fit model\npc.fitModel(model=\"HG\", method=\"trust-constr\")\nprint(\"Initial fit:\")\npc.summary()\n\n# Step 4: Monte Carlo uncertainties\npc.monteCarloUncertainty(n_simulations=500, model=\"HG\", method=\"trust-constr\")\nprint(\"With uncertainties:\")\npc.summary()\n\n# Step 5: Plot results\nmodel_angles = np.linspace(0, 25, 100)\nmodel_mags = pc.generateModel(model=\"HG\", degrees=model_angles)\n\nplt.errorbar(phase_angles, magnitudes, yerr=mag_unc, fmt='o', label='Data')\nplt.plot(model_angles, model_mags, '-', label='HG Model')\nplt.gca().invert_yaxis()\nplt.xlabel(\"Phase Angle (degrees)\")\nplt.ylabel(\"Reduced Magnitude\")\nplt.legend()\nplt.show()\n\n# Step 6: Save results\njson_data = pc.toJSON()\nwith open('results.json', 'w') as f:\n    f.write(json_data)\n</code></pre>"},{"location":"getting-started/#models-and-data-requirements","title":"Models and Data Requirements","text":"Model Parameters Min Points Recommended Points LINEAR 2 3 5+ HG 2 3 5+ HG12 2 3 5+ HG12PEN 2 3 5+ HG1G2 3 3* 5+ <p>*Due to constraint 1-G1-G2=0</p>"},{"location":"getting-started/#error-handling","title":"Error Handling","text":"<pre><code>try:\n    pc.fitModel(model=\"HG\", method=\"trust-constr\")\n    pc.monteCarloUncertainty(n_simulations=500, model=\"HG\", method=\"trust-constr\")\nexcept ValueError as e:\n    print(f\"Parameter error: {e}\")\nexcept RuntimeError as e:\n    print(f\"Fitting failed: {e}\")\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Setting Up Objects - Different ways to create PhaseCurve objects</li> <li>Fitting Models - Detailed fitting procedures</li> <li>Monte Carlo Uncertainties - Error estimation methods</li> </ul>"},{"location":"models-methods/","title":"Models and Methods","text":""},{"location":"models-methods/#model-method-compatibility","title":"Model-Method Compatibility","text":"<p>Different models have mathematical constraints that require specific optimization methods.</p>"},{"location":"models-methods/#constrained-models","title":"Constrained Models","text":"<p>These models have mathematical constraints and must use constraint-capable methods:</p> Model Constraints Required Methods HG G constraints SLSQP, COBYLA, trust-constr HG12 G12 constraints SLSQP, COBYLA, trust-constr HG12PEN G12 constraints SLSQP, COBYLA, trust-constr HG1G2 G1+G2 constraints SLSQP, COBYLA, trust-constr"},{"location":"models-methods/#unconstrained-models","title":"Unconstrained Models","text":"<p>This model can use any optimization method:</p> Model Constraints Available Methods LINEAR None (simple bounds) All methods"},{"location":"models-methods/#available-methods","title":"Available Methods","text":""},{"location":"models-methods/#constraint-capable-methods","title":"Constraint-Capable Methods","text":"<p>Required for HG, HG12, HG12PEN, HG1G2:</p> <pre><code># These methods handle mathematical constraints\npc.fitModel(model=\"HG\", method=\"trust-constr\")  # Most robust\npc.fitModel(model=\"HG\", method=\"SLSQP\")         # Fast, reliable\npc.fitModel(model=\"HG\", method=\"COBYLA\")        # Good for poor data\n</code></pre>"},{"location":"models-methods/#all-methods","title":"All Methods","text":"<p>Available for LINEAR model:</p> <pre><code># Constraint-capable methods\nmethods = ['trust-constr', 'SLSQP', 'COBYLA']\n\n# Additional methods for LINEAR only\nmethods += ['L-BFGS-B', 'TNC', 'Powell', 'least_squares',\n           'BFGS', 'CG', 'Nelder-Mead', 'leastsq']\n\n# Example\npc.fitModel(model=\"LINEAR\", method=\"leastsq\")  # Fast for unconstrained\n</code></pre>"},{"location":"models-methods/#method-characteristics","title":"Method Characteristics","text":"Method Speed Robustness Notes trust-constr Slow Excellent Most reliable for difficult cases SLSQP Medium Good Good balance of speed and reliability COBYLA Fast Good Tolerant of poor data quality leastsq Very Fast Medium LINEAR only, good for clean data L-BFGS-B Fast Good LINEAR only, handles bounds well"},{"location":"models-methods/#error-handling","title":"Error Handling","text":"<pre><code># pySPAC automatically checks compatibility\ntry:\n    pc.fitModel(model=\"HG\", method=\"leastsq\")  # Invalid!\nexcept ValueError as e:\n    print(e)\n    # Output: Model 'HG' is constrained and must use a method from: ['SLSQP', 'COBYLA', 'trust-constr']\n</code></pre>"},{"location":"models-methods/#model-complexity-and-data-requirements","title":"Model Complexity and Data Requirements","text":""},{"location":"models-methods/#parameter-count","title":"Parameter Count","text":"Model Parameters Min Points Recommended Points LINEAR 2 (H, \u03b2) 3 5+ HG 2 (H, G) 3 5+ HG12 2 (H, G12) 3 5+ HG12PEN 2 (H, G12) 3 5+ HG1G2 3 (H, G1, G2) 3* 5+ <p>*Due to constraint 1-G1-G2=0</p>"},{"location":"models-methods/#next-steps","title":"Next Steps","text":"<ul> <li>Monte Carlo Uncertainties - Parameter error estimation</li> <li>Save and Load - Save and load analysis results</li> <li>Plotting Results - Plot and display results</li> </ul>"},{"location":"plotting/","title":"Plotting Results","text":""},{"location":"plotting/#overview","title":"Overview","text":"<p>pySPAC integrates with matplotlib for visualization. Use <code>generateModel()</code> to create smooth model curves for plotting.</p>"},{"location":"plotting/#basic-phase-curve-plot","title":"Basic Phase Curve Plot","text":""},{"location":"plotting/#simple-plot","title":"Simple Plot","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\n\n# After fitting a model\npc.fitModel(model=\"HG\", method=\"trust-constr\")\n\n# Plot observational data\nplt.errorbar(pc.angle, pc.magnitude, yerr=pc.magnitude_unc,\n            fmt='o', capsize=5, label='Observations')\n\n# Generate and plot model curve\nmodel_angles = np.linspace(0, 30, 200)\nmodel_mags = pc.generateModel(model=\"HG\", degrees=model_angles)\nplt.plot(model_angles, model_mags, 'r-', label='HG Model')\n\n# Format plot\nplt.gca().invert_yaxis()  # Astronomy convention: dimmer is up\nplt.xlabel('Phase Angle (degrees)')\nplt.ylabel('Reduced Magnitude')\nplt.title('44 Nysa')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.show()\n</code></pre>"},{"location":"plotting/#enhanced-plot","title":"Enhanced Plot","text":"<pre><code>def plot_phase_curve(pc, model_name=None, title=\"Phase Curve\"):\n    \"\"\"Create enhanced phase curve plot.\"\"\"\n\n    if model_name is None:\n        model_name = pc.fitting_model\n\n    fig, ax = plt.subplots(figsize=(8, 4))\n\n    # Plot data with error bars\n    ax.errorbar(pc.angle, pc.magnitude, yerr=pc.magnitude_unc,\n               fmt='o', capsize=4, markersize=8, color='darkblue',\n               label='Photometric Data', alpha=0.8)\n\n    # Generate smooth model curve\n    angle_range = np.linspace(max(0, np.min(pc.angle)-2),\n                             np.max(pc.angle)+2, 300)\n    model_curve = pc.generateModel(model=model_name, degrees=angle_range)\n\n    ax.plot(angle_range, model_curve, 'r-', linewidth=2,\n           label=f'{model_name} Model')\n\n    # Add parameter text\n    if pc.params:\n        param_text = []\n        for param, value in pc.params.items():\n            if not param.lower().startswith('constraint'):\n                param_text.append(f'{param} = {value:.3f}')\n\n        textstr = '\\n'.join(param_text)\n        props = dict(boxstyle='round', facecolor='white', alpha=1)\n        ax.text(0.03, 0.15, textstr, transform=ax.transAxes,\n               verticalalignment='top', bbox=props)\n\n    # Formatting\n    ax.invert_yaxis()\n    ax.set_xlabel('Phase Angle (degrees)', fontsize=12)\n    ax.set_ylabel('Reduced Magnitude', fontsize=12)\n    ax.set_title(title, fontsize=14)\n    ax.legend(fontsize=11)\n    ax.grid(True, alpha=0.3)\n\n    plt.tight_layout()\n    plt.show()\n\n# Usage\nplot_phase_curve(pc, title=\"44 Nysa Phase Curve\")\n</code></pre>"},{"location":"plotting/#residual-plots","title":"Residual Plots","text":""},{"location":"plotting/#basic-residuals","title":"Basic Residuals","text":"<pre><code>def plot_residuals(pc):\n    \"\"\"Plot fit residuals.\"\"\"\n\n    if pc.fit_residual is None:\n        print(\"No residuals available - fit a model first\")\n        return\n\n    residuals = np.array(pc.fit_residual)\n\n    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(8, 4))\n\n    # Residuals vs phase angle\n    ax1.plot(pc.angle, residuals, 'o-', markersize=6)\n    ax1.axhline(y=0, color='red', linestyle='--', alpha=0.7)\n\n    # Add RMS line\n    rms = np.sqrt(np.mean(residuals**2))\n    ax1.axhline(y=rms, color='orange', linestyle=':', alpha=0.7, label=f'RMS = {rms:.4f}')\n    ax1.axhline(y=-rms, color='orange', linestyle=':', alpha=0.7)\n\n    ax1.set_xlabel('Phase Angle (degrees)')\n    ax1.set_ylabel('Residual (mag)')\n    ax1.set_title('Residuals vs Phase Angle')\n    ax1.legend()\n    ax1.grid(True, alpha=0.3)\n\n    # Residual histogram\n    ax2.hist(residuals, bins=max(3, len(residuals)//3), alpha=0.7)\n    ax2.axvline(x=0, color='red', linestyle='--', alpha=0.7)\n    ax2.set_xlabel('Residual (mag)')\n    ax2.set_ylabel('Count')\n    ax2.set_title('Residual Distribution')\n    ax2.grid(True, alpha=0.3)\n\n    plt.tight_layout()\n    plt.show()\n\n# Usage\nplot_residuals(pc)\n</code></pre>"},{"location":"plotting/#model-comparisons","title":"Model Comparisons","text":""},{"location":"plotting/#multiple-models","title":"Multiple Models","text":"<pre><code>def plot_model_comparison(pc, models=[\"HG\", \"HG12\", \"LINEAR\"]):\n    \"\"\"Compare multiple models on same data.\"\"\"\n\n    fig, ax = plt.subplots(figsize=(8, 4))\n\n    # Plot data\n    ax.errorbar(pc.angle, pc.magnitude, yerr=pc.magnitude_unc,\n               fmt='o', capsize=5, markersize=8, color='black',\n               label='Observations', zorder=10)\n\n    # Generate angle range for smooth curves\n    angle_range = np.linspace(max(0, np.min(pc.angle)-2),\n                             np.max(pc.angle)+2, 200)\n\n    colors = ['red', 'blue', 'green', 'orange', 'purple']\n\n    # Fit and plot each model\n    for i, model in enumerate(models):\n        try:\n            # Fit model\n            method = \"trust-constr\" if model != \"LINEAR\" else \"leastsq\"\n            pc.fitModel(model=model, method=method)\n\n            # Generate curve\n            model_curve = pc.generateModel(model=model, degrees=angle_range)\n\n            # Calculate RMS for legend\n            rms = np.sqrt(np.mean(np.array(pc.fit_residual)**2))\n\n            # Plot\n            color = colors[i % len(colors)]\n            ax.plot(angle_range, model_curve, '-', linewidth=2, color=color,\n                   label=f'{model} (RMS: {rms:.4f})')\n\n        except Exception as e:\n            print(f\"Failed to fit {model}: {e}\")\n\n    ax.invert_yaxis()\n    ax.set_xlabel('Phase Angle (degrees)', fontsize=12)\n    ax.set_ylabel('Reduced Magnitude', fontsize=12)\n    ax.set_title('Model Comparison', fontsize=14)\n    ax.legend(fontsize=11)\n    ax.grid(True, alpha=0.3)\n\n    plt.tight_layout()\n    plt.show()\n\n# Usage\nplot_model_comparison(pc, models=[\"HG\", \"HG12\", \"LINEAR\"])\n</code></pre>"},{"location":"plotting/#uncertainty-visualization","title":"Uncertainty Visualization","text":""},{"location":"plotting/#parameter-distributions","title":"Parameter Distributions","text":"<pre><code>def plot_parameter_distributions(pc):\n    \"\"\"Plot Monte Carlo parameter distributions.\"\"\"\n\n    if pc.montecarlo_uncertainty is None:\n        print(\"Run Monte Carlo analysis first\")\n        return\n\n    mc_data = pc.montecarlo_uncertainty\n    n_params = len(mc_data)\n\n    fig, axes = plt.subplots(1, n_params, figsize=(8,4))\n    if n_params == 1:\n        axes = [axes]\n\n    for i, (param, samples) in enumerate(mc_data.items()):\n        ax = axes[i]\n\n        # Histogram\n        ax.hist(samples, bins=50, alpha=0.7, density=True, color='skyblue')\n\n        # Add percentile lines\n        median = np.percentile(samples, 50)\n        lower = np.percentile(samples, 15.87)\n        upper = np.percentile(samples, 84.13)\n\n        ax.axvline(median, color='red', linewidth=2, label=f'Median: {median:.4f}')\n        ax.axvline(lower, color='orange', linestyle='--', alpha=0.7)\n        ax.axvline(upper, color='orange', linestyle='--', alpha=0.7)\n\n        # Shaded region\n        ax.fill_betweenx([0, ax.get_ylim()[1]], lower, upper,\n                        alpha=0.2, color='orange', label='68% CI')\n\n        ax.set_xlabel(param)\n        ax.set_ylabel('Probability Density')\n        ax.set_title(f'{param} Distribution')\n        ax.legend(fontsize=\"small\")\n        ax.grid(True, alpha=0.3)\n\n    plt.tight_layout()\n    plt.show()\n\n# Usage after Monte Carlo\npc.monteCarloUncertainty(n_simulations=50000, model=\"HG\", method=\"trust-constr\")\nplot_parameter_distributions(pc)\n</code></pre>"},{"location":"plotting/#confidence-bands","title":"Confidence Bands","text":"<pre><code>def plot_confidence_bands(pc, model_name=None, n_curves=500):\n    \"\"\"Plot phase curve with confidence bands.\"\"\"\n\n    if pc.montecarlo_uncertainty is None:\n        print(\"Run Monte Carlo analysis first\")\n        return\n\n    if model_name is None:\n        model_name = pc.fitting_model\n\n    # Generate angle range\n    angle_range = np.linspace(max(0, np.min(pc.angle)-2),\n                             np.max(pc.angle)+2, 200)\n\n    # Generate curves from Monte Carlo samples\n    mc_samples = pc.montecarlo_uncertainty\n    param_names = list(mc_samples.keys())\n    n_samples = len(mc_samples[param_names[0]])\n\n    curves = []\n    for i in range(min(n_curves, n_samples)):\n        # Create parameter set for this sample\n        temp_params = {param: samples[i] for param, samples in mc_samples.items()}\n\n        # Generate curve\n        try:\n            temp_pc = PhaseCurve(angle=angle_range, params=temp_params)\n            curve = temp_pc.generateModel(model=model_name, degrees=angle_range)\n            curves.append(curve)\n        except:\n            continue\n\n    if not curves:\n        print(\"Could not generate confidence bands\")\n        return\n\n    curves = np.array(curves)\n\n    # Calculate percentiles\n    fig, ax = plt.subplots(figsize=(10, 6))\n\n    # 68% confidence band\n    lower_68 = np.percentile(curves, 15.87, axis=0)\n    upper_68 = np.percentile(curves, 84.13, axis=0)\n    ax.fill_between(angle_range, lower_68, upper_68,\n                   alpha=0.3, color='lightblue', label='68% Confidence')\n\n    # 95% confidence band\n    lower_95 = np.percentile(curves, 2.5, axis=0)\n    upper_95 = np.percentile(curves, 97.5, axis=0)\n    ax.fill_between(angle_range, lower_95, upper_95,\n                   alpha=0.2, color='lightgray', label='95% Confidence')\n\n    # Best fit curve\n    best_fit = pc.generateModel(model=model_name, degrees=angle_range)\n    ax.plot(angle_range, best_fit, 'r-', linewidth=2, label='Best Fit')\n\n    # Data points\n    ax.errorbar(pc.angle, pc.magnitude, yerr=pc.magnitude_unc,\n               fmt='o', capsize=5, markersize=8, color='darkblue',\n               label='Data', zorder=10)\n\n    ax.invert_yaxis()\n    ax.set_xlabel('Phase Angle (degrees)')\n    ax.set_ylabel('Reduced Magnitude')\n    ax.set_title('Phase Curve with Confidence Bands')\n    ax.legend()\n    ax.grid(True, alpha=0.3)\n\n    plt.tight_layout()\n    plt.show()\n\n# Usage\nplot_confidence_bands(pc)\n</code></pre>"},{"location":"plotting/#next-steps","title":"Next Steps","text":"<ul> <li>Generate Models - Model generation from known parameters</li> </ul>"},{"location":"save-load/","title":"Save and Load","text":""},{"location":"save-load/#overview","title":"Overview","text":"<p>pySPAC provides JSON serialization to save and load complete analysis results.</p> <ul> <li><code>toJSON()</code> - Serialize PhaseCurve object to JSON string</li> <li><code>fromJSON()</code> - Reconstruct PhaseCurve object from JSON string</li> </ul>"},{"location":"save-load/#basic-save-and-load","title":"Basic Save and Load","text":""},{"location":"save-load/#saving-results","title":"Saving Results","text":"<pre><code># Complete analysis\npc = PhaseCurve(angle=angles, magnitude=mags, magnitude_unc=errors)\npc.fitModel(model=\"HG\", method=\"trust-constr\")\npc.monteCarloUncertainty(n_simulations=5000, model=\"HG\", method=\"trust-constr\")\n\n# Convert to JSON string\njson_data = pc.toJSON()\n\n# Save to file\nwith open('asteroid_analysis.json', 'w') as f:\n    f.write(json_data)\n</code></pre>"},{"location":"save-load/#loading-results","title":"Loading Results","text":"<pre><code># Load from file\nwith open('asteroid_analysis.json', 'r') as f:\n    json_data = f.read()\n\n# Reconstruct PhaseCurve object\npc_loaded = PhaseCurve.fromJSON(json_data)\n\n# All data and results are preserved\npc_loaded.summary()\n</code></pre>"},{"location":"save-load/#what-gets-saved","title":"What Gets Saved","text":""},{"location":"save-load/#complete-state-preservation","title":"Complete State Preservation","text":"<p>The JSON format preserves:</p> <ul> <li>Observational data: <code>angle</code>, <code>magnitude</code>, <code>magnitude_unc</code></li> <li>Model parameters: <code>params</code> dictionary</li> <li>Fit results: <code>fitting_status</code>, <code>fitting_model</code>, <code>fitting_method</code>, <code>fit_residual</code></li> <li>Monte Carlo data: <code>montecarlo_uncertainty</code>, <code>uncertainty_results</code>, <code>uncertainty_source</code></li> <li>All other attributes: Complete object state</li> </ul>"},{"location":"save-load/#whats-not-saved","title":"What's Not Saved","text":"<pre><code># The lmfit ModelResult object is not saved (not JSON serializable)\n# This means lmfit covariance errors are not available after reload\n# Use Monte Carlo uncertainties for reloaded objects\n</code></pre>"},{"location":"save-load/#file-operations","title":"File Operations","text":""},{"location":"save-load/#simple-file-saveload","title":"Simple File Save/Load","text":"<pre><code>def save_analysis(pc, filename):\n    \"\"\"Save PhaseCurve analysis to file.\"\"\"\n    json_data = pc.toJSON()\n    with open(filename, 'w') as f:\n        f.write(json_data)\n    print(f\"Saved to {filename}\")\n\ndef load_analysis(filename):\n    \"\"\"Load PhaseCurve analysis from file.\"\"\"\n    with open(filename, 'r') as f:\n        json_data = f.read()\n    pc = PhaseCurve.fromJSON(json_data)\n    print(f\"Loaded from {filename}\")\n    return pc\n\n# Usage\nsave_analysis(pc, 'my_asteroid.json')\npc_reloaded = load_analysis('my_asteroid.json')\n</code></pre>"},{"location":"save-load/#error-handling","title":"Error Handling","text":"<pre><code>def safe_save(pc, filename):\n    \"\"\"Save with error handling.\"\"\"\n    try:\n        json_data = pc.toJSON()\n        with open(filename, 'w') as f:\n            f.write(json_data)\n        return True\n    except Exception as e:\n        print(f\"Save failed: {e}\")\n        return False\n\ndef safe_load(filename):\n    \"\"\"Load with error handling.\"\"\"\n    try:\n        with open(filename, 'r') as f:\n            json_data = f.read()\n        pc = PhaseCurve.fromJSON(json_data)\n        return pc\n    except FileNotFoundError:\n        print(f\"File not found: {filename}\")\n    except json.JSONDecodeError:\n        print(f\"Invalid JSON in {filename}\")\n    except Exception as e:\n        print(f\"Load failed: {e}\")\n    return None\n\n# Usage\nif safe_save(pc, 'analysis.json'):\n    pc_loaded = safe_load('analysis.json')\n</code></pre>"},{"location":"save-load/#batch-operations","title":"Batch Operations","text":""},{"location":"save-load/#save-multiple-objects","title":"Save Multiple Objects","text":"<pre><code>def save_batch_analyses(objects_dict, filename):\n    \"\"\"Save multiple PhaseCurve objects to one file.\"\"\"\n\n    batch_data = {}\n    for name, pc in objects_dict.items():\n        try:\n            batch_data[name] = pc.toJSON()\n        except Exception as e:\n            print(f\"Failed to save {name}: {e}\")\n\n    with open(filename, 'w') as f:\n        json.dump(batch_data, f, indent=2)\n\n    print(f\"Saved {len(batch_data)} objects to {filename}\")\n\ndef load_batch_analyses(filename):\n    \"\"\"Load multiple PhaseCurve objects from one file.\"\"\"\n\n    with open(filename, 'r') as f:\n        batch_data = json.load(f)\n\n    objects = {}\n    for name, json_str in batch_data.items():\n        try:\n            objects[name] = PhaseCurve.fromJSON(json_str)\n        except Exception as e:\n            print(f\"Failed to load {name}: {e}\")\n\n    print(f\"Loaded {len(objects)} objects from {filename}\")\n    return objects\n\n# Usage\nasteroids = {\n    'Ceres': pc1,\n    'Vesta': pc2,\n    'Pallas': pc3\n}\n\nsave_batch_analyses(asteroids, 'asteroid_batch.json')\nloaded_asteroids = load_batch_analyses('asteroid_batch.json')\n</code></pre>"},{"location":"save-load/#process-multiple-files","title":"Process Multiple Files","text":"<pre><code>import glob\nimport os\n\ndef process_directory(input_dir, output_dir):\n    \"\"\"Process all JSON files in a directory.\"\"\"\n\n    if not os.path.exists(output_dir):\n        os.makedirs(output_dir)\n\n    json_files = glob.glob(os.path.join(input_dir, \"*.json\"))\n\n    for filepath in json_files:\n        try:\n            # Load object\n            pc = safe_load(filepath)\n            if pc is None:\n                continue\n\n            # Process (example: add Monte Carlo if missing)\n            if pc.uncertainty_results is None and pc.fitting_status:\n                pc.monteCarloUncertainty(\n                    n_simulations=3000,\n                    model=pc.fitting_model,\n                    method=\"trust-constr\",\n                    verbose=False\n                )\n\n            # Save processed version\n            filename = os.path.basename(filepath)\n            output_path = os.path.join(output_dir, f\"processed_{filename}\")\n            safe_save(pc, output_path)\n\n        except Exception as e:\n            print(f\"Error processing {filepath}: {e}\")\n\n# Usage\nprocess_directory('raw_analyses/', 'processed_analyses/')\n</code></pre>"},{"location":"save-load/#data-management","title":"Data Management","text":""},{"location":"save-load/#add-metadata","title":"Add Metadata","text":"<pre><code>def save_with_metadata(pc, filename, metadata=None):\n    \"\"\"Save with additional metadata.\"\"\"\n\n    # Get base object data\n    json_str = pc.toJSON()\n    base_data = json.loads(json_str)\n\n    # Add metadata wrapper\n    save_data = {\n        'pySPAC_version': '1.0',\n        'save_date': '2024-01-15',\n        'metadata': metadata or {},\n        'phasecurve_data': base_data\n    }\n\n    with open(filename, 'w') as f:\n        json.dump(save_data, f, indent=2)\n\ndef load_with_metadata(filename):\n    \"\"\"Load and extract metadata.\"\"\"\n\n    with open(filename, 'r') as f:\n        save_data = json.load(f)\n\n    # Extract metadata\n    metadata = {\n        'version': save_data.get('pySPAC_version'),\n        'save_date': save_data.get('save_date'),\n        'custom': save_data.get('metadata', {})\n    }\n\n    # Reconstruct object\n    if 'phasecurve_data' in save_data:\n        pc = PhaseCurve.fromJSON(json.dumps(save_data['phasecurve_data']))\n    else:\n        # Fallback for simple format\n        pc = PhaseCurve.fromJSON(json.dumps(save_data))\n        metadata = {}\n\n    return pc, metadata\n\n# Usage\nmetadata = {\n    'object_name': '433 Eros',\n    'observer': 'Smith et al.',\n    'telescope': 'Palomar 200-inch',\n    'filter': 'V-band'\n}\n\nsave_with_metadata(pc, 'eros_analysis.json', metadata)\npc_loaded, meta = load_with_metadata('eros_analysis.json')\nprint(f\"Metadata: {meta}\")\n</code></pre>"},{"location":"save-load/#compressed-storage","title":"Compressed Storage","text":"<pre><code>import gzip\n\ndef save_compressed(pc, filename):\n    \"\"\"Save with gzip compression.\"\"\"\n\n    json_str = pc.toJSON()\n\n    with gzip.open(filename, 'wt') as f:\n        f.write(json_str)\n\n    # Report compression ratio\n    original_size = len(json_str)\n    compressed_size = os.path.getsize(filename)\n    ratio = compressed_size / original_size\n\n    print(f\"Compressed: {original_size:,} \u2192 {compressed_size:,} bytes ({ratio:.1%})\")\n\ndef load_compressed(filename):\n    \"\"\"Load compressed file.\"\"\"\n\n    with gzip.open(filename, 'rt') as f:\n        json_str = f.read()\n\n    return PhaseCurve.fromJSON(json_str)\n\n# Usage\nsave_compressed(pc, 'analysis.json.gz')\npc_loaded = load_compressed('analysis.json.gz')\n</code></pre>"},{"location":"save-load/#validation-after-loading","title":"Validation After Loading","text":"<pre><code>def validate_loaded_object(pc):\n    \"\"\"Validate loaded PhaseCurve object.\"\"\"\n\n    issues = []\n\n    # Check basic data\n    if pc.angle is None or pc.magnitude is None:\n        issues.append(\"Missing observational data\")\n    elif len(pc.angle) != len(pc.magnitude):\n        issues.append(\"Data arrays have different lengths\")\n\n    # Check fit consistency\n    if pc.fitting_status and not pc.params:\n        issues.append(\"Fitting status true but no parameters\")\n\n    # Check Monte Carlo consistency\n    if pc.montecarlo_uncertainty and not pc.uncertainty_results:\n        issues.append(\"Monte Carlo samples exist but no processed results\")\n\n    if issues:\n        print(\"Validation issues:\")\n        for issue in issues:\n            print(f\"  - {issue}\")\n        return False\n    else:\n        print(\"Object validation passed\")\n        return True\n\n# Usage\npc_loaded = safe_load('analysis.json')\nif pc_loaded and validate_loaded_object(pc_loaded):\n    pc_loaded.summary()\n</code></pre>"},{"location":"save-load/#next-steps","title":"Next Steps","text":"<ul> <li>Plotting Results - Plot and display results</li> <li>Generate Models - Model generation from known parameters</li> </ul>"},{"location":"setup-objects/","title":"Setting Up Objects","text":""},{"location":"setup-objects/#phasecurve-constructor","title":"PhaseCurve Constructor","text":"<pre><code>PhaseCurve(angle, magnitude=None, magnitude_unc=None, params=None,\n           H=None, G=None, G12=None, G1=None, G2=None, beta=None)\n</code></pre>"},{"location":"setup-objects/#from-observational-data","title":"From Observational Data","text":""},{"location":"setup-objects/#basic-setup","title":"Basic Setup","text":"<pre><code>import numpy as np\nfrom pyspac import PhaseCurve\n\n# Required: angles and magnitudes\nangles = np.array([0.17, 0.63, 0.98, 1.62, 4.95, 9.78,\n                  12.94, 13.27, 13.81, 17.16, 18.52, 19.4])\nmags = np.array([6.911, 7.014, 7.052, 7.105, 7.235, 7.341,\n                7.425, 7.427, 7.437, 7.511, 7.551, 7.599])\npc = PhaseCurve(angle=angles, magnitude=mags)\n</code></pre>"},{"location":"setup-objects/#with-uncertainties-recommended","title":"With Uncertainties (Recommended)","text":"<pre><code># Include magnitude uncertainties for weighted fitting\nangles = np.array([0.17, 0.63, 0.98, 1.62, 4.95, 9.78,\n                  12.94, 13.27, 13.81, 17.16, 18.52, 19.4])\nmags = np.array([6.911, 7.014, 7.052, 7.105, 7.235, 7.341,\n                7.425, 7.427, 7.437, 7.511, 7.551, 7.599])\nerrors = np.array([0.02, 0.02, 0.03, 0.03, 0.04, 0.04,\n                   0.02, 0.02, 0.03, 0.03, 0.04, 0.04])\n\npc = PhaseCurve(angle=angles, magnitude=mags, magnitude_unc=errors)\n</code></pre>"},{"location":"setup-objects/#from-model-parameters","title":"From Model Parameters","text":""},{"location":"setup-objects/#individual-parameters","title":"Individual Parameters","text":"<pre><code># HG model\nangles = np.linspace(0, 30, 100)\npc = PhaseCurve(angle=angles, H=15.0, G=0.25)\n\n# HG1G2 model\npc = PhaseCurve(angle=angles, H=15.0, G1=0.3, G2=0.1)\n\n# HG12 model\npc = PhaseCurve(angle=angles, H=15.0, G12=0.3)\n\n# Linear model\npc = PhaseCurve(angle=angles, H=15.0, beta=0.04)\n</code></pre>"},{"location":"setup-objects/#using-parameters-dictionary","title":"Using Parameters Dictionary","text":"<pre><code># HG parameters\nhg_params = {\"H\": 15.0, \"G\": 0.25}\npc = PhaseCurve(angle=angles, params=hg_params)\n\n# HG1G2 parameters\nhg1g2_params = {\"H\": 15.0, \"G1\": 0.3, \"G2\": 0.1}\npc = PhaseCurve(angle=angles, params=hg1g2_params)\n</code></pre>"},{"location":"setup-objects/#input-formats","title":"Input Formats","text":"<pre><code># Python lists\npc = PhaseCurve(angle=[5, 10, 15], magnitude=[15.2, 15.4, 15.7])\n\n# Numpy arrays\nangles = np.array([5, 10, 15])\nmags = np.array([15.2, 15.4, 15.7])\npc = PhaseCurve(angle=angles, magnitude=mags)\n\n# Single values\npc = PhaseCurve(angle=10.0, magnitude=15.5)\n</code></pre>"},{"location":"setup-objects/#data-validation","title":"Data Validation","text":"<pre><code># Arrays must have same shape\ntry:\n    pc = PhaseCurve(angle=[5, 10, 15], magnitude=[15.2, 15.4])  # Wrong!\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n\n# No NaN or infinite values allowed\ntry:\n    pc = PhaseCurve(angle=[5, 10, np.nan], magnitude=[15.2, 15.4, 15.7])\nexcept ValueError as e:\n    print(f\"Error: {e}\")\n</code></pre>"},{"location":"setup-objects/#object-properties","title":"Object Properties","text":"<pre><code>pc = PhaseCurve(angle=[5, 10, 15], magnitude=[15.2, 15.4, 15.7])\n\n# Data arrays (converted to numpy arrays internally)\nprint(pc.angle)        # [5 10 15]\nprint(pc.magnitude)    # [15.2 15.4 15.7]\nprint(pc.magnitude_unc)  # None if not provided\n\n# Parameters dictionary\nprint(pc.params)       # {} initially, populated after fitting\n\n# Fitting status\nprint(pc.fitting_status)  # False initially\nprint(pc.fitting_model)   # None initially\n</code></pre>"},{"location":"setup-objects/#combining-data-and-parameters","title":"Combining Data and Parameters","text":"<pre><code># Start with parameters, then add observational data for comparison\npc = PhaseCurve(angle=angles, H=15.0, G=0.25)\n\n# Later, you can still set observational data\npc.magnitude = observed_mags\npc.magnitude_unc = observed_errors\n</code></pre>"},{"location":"setup-objects/#string-representation","title":"String Representation","text":"<pre><code>pc = PhaseCurve(angle=[5, 10, 15], magnitude=[15.2, 15.4, 15.7])\nprint(pc)\n# Output: &lt;PhaseCurve object with 3 data points | Not yet fitted&gt;\n</code></pre>"},{"location":"setup-objects/#next-steps","title":"Next Steps","text":"<ul> <li>Fitting Models - Detailed fitting procedures</li> <li>Setting Boundaries - Control parameter bounds and initial guesses</li> <li>Models and Methods - Model/method compatibility details</li> </ul>"},{"location":"uncertainties/","title":"Monte Carlo Uncertainties","text":""},{"location":"uncertainties/#overview","title":"Overview","text":"<p>pySPAC provides two Monte Carlo methods for parameter uncertainty estimation:</p> <ol> <li><code>monteCarloUncertainty()</code> - Uses only observational errors</li> <li><code>monteCarloUnknownRotation()</code> - Estimates rotational lightcurve scatter</li> </ol>"},{"location":"uncertainties/#method-1-observational-uncertainties","title":"Method 1: Observational Uncertainties","text":""},{"location":"uncertainties/#basic-usage","title":"Basic Usage","text":"<pre><code># Fit model first\npc.fitModel(model=\"HG\", method=\"trust-constr\")\n\n# Run Monte Carlo with observational errors\npc.monteCarloUncertainty(\n    n_simulations=500,\n    model=\"HG\",\n    method=\"trust-constr\"\n)\n\n# View results\npc.summary()\n</code></pre>"},{"location":"uncertainties/#method-signature","title":"Method Signature","text":"<pre><code>monteCarloUncertainty(n_simulations, model, method, n_threads=1, verbose=True)\n</code></pre> <p>Parameters:</p> <ul> <li>n_simulations (int): Number of Monte Carlo iterations</li> <li>model (str): Model to fit in each simulation</li> <li>method (str): Optimization method</li> <li>n_threads (int): Number of parallel threads (default: 1)</li> <li>verbose (bool): Show progress bar (default: True)</li> </ul>"},{"location":"uncertainties/#how-it-works","title":"How It Works","text":"<ol> <li>Generate simulated datasets by adding Gaussian noise based on <code>magnitude_unc</code></li> <li>Fit the model to each noisy dataset</li> <li>Collect successful parameter estimates</li> <li>Calculate percentile-based uncertainties</li> </ol>"},{"location":"uncertainties/#without-magnitude-uncertainties","title":"Without Magnitude Uncertainties","text":"<pre><code># If no uncertainties provided, pySPAC estimates from RMS\npc = PhaseCurve(angle=angles, magnitude=mags)  # No magnitude_unc\npc.fitModel(model=\"HG\", method=\"trust-constr\")\n\n# Automatically estimates uniform uncertainties\npc.monteCarloUncertainty(n_simulations=500, model=\"HG\", method=\"trust-constr\")\n</code></pre>"},{"location":"uncertainties/#method-2-unknown-rotational-variation","title":"Method 2: Unknown Rotational Variation","text":""},{"location":"uncertainties/#basic-usage_1","title":"Basic Usage","text":"<pre><code># Include rotational scatter in uncertainty analysis\npc.monteCarloUnknownRotation(\n    n_simulations=500,\n    amplitude_variation=0.15,  # 0.15 mag rotational amplitude\n    model=\"HG\",\n    distribution='sinusoidal',\n    method=\"trust-constr\",\n)\n</code></pre>"},{"location":"uncertainties/#method-signature_1","title":"Method Signature","text":"<pre><code>monteCarloUnknownRotation(n_simulations, amplitude_variation, model,\n                         distribution=\"sinusoidal\", method=\"trust-constr\",\n                         n_threads=1, verbose=True)\n</code></pre> <p>Parameters:</p> <ul> <li>amplitude_variation (float): Semi-amplitude of rotational variation (magnitudes)</li> <li>distribution (str): \"sinusoidal\" or \"uniform\" (default: \"sinusoidal\")</li> <li>Other parameters same as <code>monteCarloUncertainty</code></li> </ul>"},{"location":"uncertainties/#rotational-amplitude-guide","title":"Rotational Amplitude Guide","text":"<pre><code># Typical asteroid rotational amplitudes\namplitudes = {\n    'spherical': 0.05,      # Nearly spherical objects\n    'typical': 0.15,        # Average asteroids\n    'elongated': 0.25,      # Highly elongated objects\n    'binary': 0.40,         # Binary systems\n    'extreme': 0.60         # Extreme cases\n}\n\n# Usage\npc.monteCarloUnknownRotation(\n    n_simulations=500,\n    amplitude_variation=amplitudes['typical'],\n    model=\"HG\",\n    distribution='sinusoidal',\n    method=\"trust-constr\"\n)\n</code></pre>"},{"location":"uncertainties/#distribution-types","title":"Distribution Types","text":"<pre><code># Sinusoidal distribution (realistic for most asteroids)\npc.monteCarloUnknownRotation(\n    n_simulations=500,\n    amplitude_variation=0.15,\n    distribution=\"sinusoidal\",\n    model=\"HG\",\n    method=\"trust-constr\"\n)\n\n# Uniform distribution (conservative estimate)\npc.monteCarloUnknownRotation(\n    n_simulations=500,\n    amplitude_variation=0.15,\n    distribution=\"uniform\",\n    model=\"HG\",\n    method=\"trust-constr\"\n)\n</code></pre>"},{"location":"uncertainties/#using-different-percentiles","title":"Using Different Percentiles","text":""},{"location":"uncertainties/#default-percentiles-68-confidence","title":"Default Percentiles (68% confidence)","text":"<pre><code># Default: 15.87%, 50%, 84.13% (\u00b11\u03c3 equivalent)\npc.monteCarloUncertainty(n_simulations=500, model=\"HG\", method=\"trust-constr\")\npc.summary()  # Shows default 68% confidence intervals\n</code></pre>"},{"location":"uncertainties/#custom-confidence-levels","title":"Custom Confidence Levels","text":"<pre><code># 95% confidence interval (2\u03c3 equivalent)\npc.calculate_uncertainties(percentiles=[2.5, 50, 97.5])\npc.summary()\n\n# 99% confidence interval (3\u03c3 equivalent)\npc.calculate_uncertainties(percentiles=[0.5, 50, 99.5])\npc.summary()\n\n# 90% confidence interval\npc.calculate_uncertainties(percentiles=[5, 50, 95])\npc.summary()\n</code></pre>"},{"location":"uncertainties/#multiple-confidence-levels","title":"Multiple Confidence Levels","text":"<pre><code>def show_multiple_confidence_levels(pc):\n    \"\"\"Display uncertainties at multiple confidence levels.\"\"\"\n\n    levels = [\n        ([15.87, 50, 84.13], \"68% (1\u03c3)\"),\n        ([2.5, 50, 97.5], \"95% (2\u03c3)\"),\n        ([0.5, 50, 99.5], \"99% (3\u03c3)\")\n    ]\n\n    print(f\"{'Parameter':&lt;10} {'Level':&lt;10} {'Median':&lt;8} {'Lower':&lt;8} {'Upper':&lt;8}\")\n    print(\"-\" * 50)\n\n    for percentiles, label in levels:\n        pc.calculate_uncertainties(percentiles=percentiles)\n\n        for param, stats in pc.uncertainty_results.items():\n            median = stats['median']\n            lower = stats['lower_error']\n            upper = stats['upper_error']\n            print(f\"{param:&lt;10} {label:&lt;10} {median:&lt;8.4f} {lower:&lt;8.4f} {upper:&lt;8.4f}\")\n\n# Usage after Monte Carlo analysis\nshow_multiple_confidence_levels(pc)\n</code></pre>"},{"location":"uncertainties/#accessing-results","title":"Accessing Results","text":""},{"location":"uncertainties/#raw-monte-carlo-samples","title":"Raw Monte Carlo Samples","text":"<pre><code># Access raw parameter samples\nmc_samples = pc.montecarlo_uncertainty\n\nfor param, values in mc_samples.items():\n    print(f\"{param}: {len(values)} samples\")\n    print(f\"  Mean: {np.mean(values):.4f}\")\n    print(f\"  Std: {np.std(values):.4f}\")\n</code></pre>"},{"location":"uncertainties/#processed-uncertainties","title":"Processed Uncertainties","text":"<pre><code># Access processed uncertainty statistics\nuncertainties = pc.uncertainty_results\n\nfor param, stats in uncertainties.items():\n    print(f\"{param}:\")\n    print(f\"  Median: {stats['median']:.4f}\")\n    print(f\"  Upper error: +{stats['upper_error']:.4f}\")\n    print(f\"  Lower error: {stats['lower_error']:.4f}\")\n    print(f\"  Percentiles: {stats['percentiles']}\")\n</code></pre>"},{"location":"uncertainties/#thread-usage","title":"Thread Usage","text":"<pre><code>import multiprocessing as mp\n\n# Use multiple threads for faster computation\nn_threads = min(4, mp.cpu_count())  # Don't exceed 4 threads\n\npc.monteCarloUncertainty(\n    n_simulations=500,\n    model=\"HG\",\n    method=\"trust-constr\",\n    n_threads=n_threads\n)\n</code></pre>"},{"location":"uncertainties/#choosing-between-methods","title":"Choosing Between Methods","text":""},{"location":"uncertainties/#decision-framework","title":"Decision Framework","text":"<pre><code>def choose_uncertainty_method(has_uncertainties, rotational_knowledge):\n    \"\"\"Choose appropriate uncertainty method.\"\"\"\n\n    if rotational_knowledge == \"negligible\":\n        # Rotational amplitude &lt; 0.05 mag\n        return \"monteCarloUncertainty\"\n\n    elif rotational_knowledge == \"unknown\":\n        # Unknown rotational state - conservative approach\n        return \"monteCarloUnknownRotation\"\n\n    elif rotational_knowledge == \"significant\":\n        # Known large rotational amplitude\n        return \"monteCarloUnknownRotation\"\n\n    elif not has_uncertainties:\n        # No observational errors - estimate both sources\n        return \"monteCarloUnknownRotation\"\n\n    else:\n        # Standard case with observational errors\n        return \"monteCarloUncertainty\"\n\n# Usage\nmethod = choose_uncertainty_method(\n    has_uncertainties=True,\n    rotational_knowledge=\"unknown\"\n)\nprint(f\"Recommended method: {method}\")\n</code></pre>"},{"location":"uncertainties/#typical-use-cases","title":"Typical Use Cases","text":"<pre><code># Case 1: High-quality photometry, known spherical object\npc.monteCarloUncertainty(n_simulations=500, model=\"HG\", method=\"trust-constr\")\n\n# Case 2: Standard photometry, unknown rotation\npc.monteCarloUnknownRotation(\n    n_simulations=500,\n    amplitude_variation=0.15,  # Typical asteroid\n    model=\"HG\",\n    method=\"trust-constr\"\n)\n\n# Case 3: Sparse data, possibly elongated object\npc.monteCarloUnknownRotation(\n    n_simulations=500,\n    amplitude_variation=0.25,  # Conservative estimate\n    model=\"HG\",\n    distribution=\"uniform\",    # Conservative distribution\n    method=\"trust-constr\"\n)\n</code></pre>"},{"location":"uncertainties/#validation-and-diagnostics","title":"Validation and Diagnostics","text":""},{"location":"uncertainties/#convergence-check","title":"Convergence Check","text":"<pre><code>def check_convergence(pc, target_precision=0.02):\n    \"\"\"Check if Monte Carlo has converged.\"\"\"\n\n    samples = pc.montecarlo_uncertainty\n\n    for param, values in samples.items():\n        n_samples = len(values)\n\n        # Split into two halves\n        half = n_samples // 2\n        first_half = values[:half]\n        second_half = values[half:2*half]\n\n        # Compare standard deviations\n        std1 = np.std(first_half)\n        std2 = np.std(second_half)\n\n        relative_diff = abs(std1 - std2) / max(std1, std2)\n\n        if relative_diff &gt; target_precision:\n            print(f\"WARNING: {param} may not be converged ({relative_diff:.4f})\")\n        else:\n            print(f\"OK: {param} converged ({relative_diff:.4f})\")\n\n# Usage after Monte Carlo\ncheck_convergence(pc)\n</code></pre>"},{"location":"uncertainties/#sample-quality","title":"Sample Quality","text":"<pre><code>def analyze_sample_quality(pc):\n    \"\"\"Analyze quality of Monte Carlo samples.\"\"\"\n\n    samples = pc.montecarlo_uncertainty\n\n    for param, values in samples.items():\n        # Basic statistics\n        mean_val = np.mean(values)\n        median_val = np.median(values)\n        std_val = np.std(values)\n\n        # Skewness and kurtosis\n        from scipy import stats\n        skewness = stats.skew(values)\n        kurtosis = stats.kurtosis(values)\n\n        print(f\"{param}:\")\n        print(f\"  Samples: {len(values)}\")\n        print(f\"  Mean: {mean_val:.4f}, Median: {median_val:.4f}\")\n        print(f\"  Std: {std_val:.4f}\")\n        print(f\"  Skewness: {skewness:.3f}, Kurtosis: {kurtosis:.3f}\")\n\n        # Flag potential issues\n        if abs(skewness) &gt; 1:\n            print(f\"  WARNING: High skewness\")\n        if abs(kurtosis) &gt; 3:\n            print(f\"  WARNING: High kurtosis\")\n\n# Usage\nanalyze_sample_quality(pc)\n</code></pre>"},{"location":"uncertainties/#performance-optimization","title":"Performance Optimization","text":""},{"location":"uncertainties/#efficient-settings","title":"Efficient Settings","text":"<pre><code># For production analysis\npc.monteCarloUncertainty(\n    n_simulations=500,\n    model=\"HG\",\n    method=\"trust-constr\",\n    n_threads=4,\n    verbose=False  # Disable progress bar\n)\n\n# For interactive exploration\npc.monteCarloUncertainty(\n    n_simulations=100,  # Fewer simulations for speed\n    model=\"HG\",\n    method=\"trust-constr\",\n    verbose=True\n)\n</code></pre>"},{"location":"uncertainties/#next-steps","title":"Next Steps","text":"<ul> <li>Save and Load - Save and load analysis results</li> <li>Plotting Results - Plot and display results</li> <li>Generate Models - Model generation from known parameters</li> </ul>"}]}